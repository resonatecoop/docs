"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[32],{3905:(n,e,t)=>{t.d(e,{Zo:()=>u,kt:()=>m});var r=t(7294);function o(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function s(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function a(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?s(Object(t),!0).forEach((function(e){o(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function i(n,e){if(null==n)return{};var t,r,o=function(n,e){if(null==n)return{};var t,r,o={},s=Object.keys(n);for(r=0;r<s.length;r++)t=s[r],e.indexOf(t)>=0||(o[t]=n[t]);return o}(n,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);for(r=0;r<s.length;r++)t=s[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(o[t]=n[t])}return o}var c=r.createContext({}),p=function(n){var e=r.useContext(c),t=e;return n&&(t="function"==typeof n?n(e):a(a({},e),n)),t},u=function(n){var e=p(n.components);return r.createElement(c.Provider,{value:e},n.children)},l={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},d=r.forwardRef((function(n,e){var t=n.components,o=n.mdxType,s=n.originalType,c=n.parentName,u=i(n,["components","mdxType","originalType","parentName"]),d=p(t),m=o,h=d["".concat(c,".").concat(m)]||d[m]||l[m]||s;return t?r.createElement(h,a(a({ref:e},u),{},{components:t})):r.createElement(h,a({ref:e},u))}));function m(n,e){var t=arguments,o=e&&e.mdxType;if("string"==typeof n||o){var s=t.length,a=new Array(s);a[0]=d;var i={};for(var c in e)hasOwnProperty.call(e,c)&&(i[c]=e[c]);i.originalType=n,i.mdxType="string"==typeof n?n:o,a[1]=i;for(var p=2;p<s;p++)a[p]=t[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},3661:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>s,metadata:()=>i,toc:()=>p});var r=t(7462),o=(t(7294),t(3905));const s={sidebar_position:2,title:"Example API Calls"},a=void 0,i={unversionedId:"example-api-calls",id:"example-api-calls",title:"Example API Calls",description:"Explore sample client API calls, illustrated by the beam repository's Api.ts file...",source:"@site/docs/example-api-calls.md",sourceDirName:".",slug:"/example-api-calls",permalink:"/docs/example-api-calls",draft:!1,editUrl:"https://github.com/resonatecoop/beam/edit/main/src/services/Api.ts",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Example API Calls"},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/docs/overview"},next:{title:"Active Development",permalink:"/docs/category/active-development"}},c={},p=[],u={toc:p};function l(n){let{components:e,...t}=n;return(0,o.kt)("wrapper",(0,r.Z)({},u,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Explore sample client API calls, illustrated by the ",(0,o.kt)("code",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/resonatecoop/beam"},"beam"))," repository's ",(0,o.kt)("code",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/resonatecoop/beam/blob/main/src/services/Api.ts"},"Api.ts"))," file..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { resonateUrl } from "../constants";\n\nconst API = `${resonateUrl}api/`;\nexport const oidcStorage = `oidc.user:${process.env.REACT_APP_AUTHORITY}:${process.env.REACT_APP_CLIENT_ID}`;\n\nclass NotFoundError extends Error {\n  constructor(params: any) {\n    super(params);\n    Object.setPrototypeOf(this, NotFoundError.prototype);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, NotFoundError);\n    }\n\n    this.message = "Not Found";\n  }\n}\n\nexport const getToken = (apiVersion?: string | number) => {\n  let token: string | undefined = undefined;\n  try {\n    const stateString = localStorage.getItem("state");\n    const state = JSON.parse(stateString ?? "");\n    token = state?.token;\n  } catch (e) {}\n\n  let version = apiVersion ?? "v3";\n\n  try {\n    const oauthStateString = localStorage.getItem(oidcStorage);\n    const oauthState = JSON.parse(oauthStateString ?? "");\n    token = oauthState.access_token;\n    version = apiVersion ?? "v3";\n  } catch (e) {}\n  return { token: token, version };\n};\n\nconst fetchWrapper = async (\n  url: string,\n  options: RequestInit,\n  apiOptions?: APIOptions,\n  pagination?: boolean\n) => {\n  const { token, version: apiVersion } = getToken(apiOptions?.apiVersion);\n  let fullUrl = `${API}${apiVersion}/${url}`;\n  if (apiOptions && options.method === "GET") {\n    const params = new URLSearchParams();\n    Object.keys(apiOptions).forEach((key) => {\n      params.set(key, `${apiOptions[key]}`);\n    });\n    fullUrl += `?${params}`;\n  }\n\n  return fetch(fullUrl, {\n    headers: {\n      "Content-Type": "application/json",\n      ...(token ? { Authorization: `Bearer ${token}` } : {}),\n    },\n    ...options,\n  })\n    .then((result) => {\n      if (!result.ok) {\n        if (result.status === 404) {\n          throw new NotFoundError(result);\n        }\n      } else {\n        // go the desired response\n      }\n      return result.json();\n    })\n    .then((result) => {\n      if (pagination) {\n        return result;\n      }\n      return result.data;\n    });\n};\n\nexport const fetchUserProfile = async (): Promise<LoggedInUser> => {\n  return fetchWrapper("user/profile/", {\n    method: "GET",\n  });\n};\n\nexport const fetchUserPlaylists = async (\n  id: number,\n  options?: APIOptions\n): Promise<Trackgroup[]> => {\n  return fetchWrapper(\n    `users/${id}/playlists`,\n    {\n      method: "GET",\n    },\n    options\n  );\n};\n\ninterface FetchTrackGroupFilter extends APIOptions {\n  type?: TrackgroupType;\n}\n\n// FIXME: What\'s the difference between fetching a user\'s playlists\n// (as with the staff picks) and fetching the user\'s trackgroups.\n// Also note that if you don\'t supply a type, then the listing returns\n// 0. That might be an API error?\nexport const fetchUserTrackGroups = async (\n  options?: FetchTrackGroupFilter\n): Promise<TrackgroupDetail[]> => {\n  return fetchWrapper(\n    `user/trackgroups`,\n    {\n      method: "GET",\n    },\n    options\n  );\n};\n\nexport const fetchTrackGroups = async (\n  options?: FetchTrackGroupFilter\n): Promise<APIPaginatedResult<Trackgroup>> => {\n  return fetchWrapper(\n    "trackgroups",\n    {\n      method: "GET",\n    },\n    options,\n    true\n  );\n};\n\nexport const fetchTrackGroup = async (\n  id: string\n): Promise<TrackgroupDetail> => {\n  return fetchWrapper(`trackgroups/${id}`, {\n    method: "GET",\n  });\n};\n\n/**\n * User track groups\n */\n\nexport const createTrackGroup = async (data: {\n  cover: string;\n  title: string;\n  type: string;\n}): Promise<TrackgroupDetail> => {\n  return fetchWrapper(`user/trackgroups`, {\n    method: "POST",\n    body: JSON.stringify(data),\n  });\n};\n\nexport const updateTrackGroup = async (\n  id: string,\n  data: {\n    cover: string;\n    title: string;\n    private: boolean;\n    tags: string[];\n    type: string;\n    about?: string;\n  }\n): Promise<TrackgroupDetail> => {\n  return fetchWrapper(`user/trackgroups/${id}`, {\n    method: "PUT",\n    body: JSON.stringify(data),\n  });\n};\n\nexport const fetchUserTrackGroup = async (\n  id: string\n): Promise<TrackgroupDetail> => {\n  return fetchWrapper(`user/trackgroups/${id}`, {\n    method: "GET",\n  });\n};\n\nexport const addTracksToTrackGroup = async (\n  id: string,\n  data: {\n    tracks: { track_id: number }[];\n  }\n) => {\n  return fetchWrapper(`user/trackgroups/${id}/items/add`, {\n    method: "PUT",\n    body: JSON.stringify(data),\n  });\n};\n\nexport const removeTracksFromTrackGroup = async (\n  id: string,\n  data: {\n    tracks: { track_id: number }[];\n  }\n) => {\n  return fetchWrapper(`user/trackgroups/${id}/items/remove`, {\n    method: "PUT",\n    body: JSON.stringify(data),\n  });\n};\n\nexport const setNewTracksOnTrackGroup = async (\n  id: string,\n  data: {\n    tracks: { track_id: number; index?: number }[];\n  }\n) => {\n  return fetchWrapper(`user/trackgroups/${id}/items`, {\n    method: "PUT",\n    body: JSON.stringify(data),\n  });\n};\n\nexport const deleteUserTrackGroup = async (id: string) => {\n  return fetchWrapper(`user/trackgroups/${id}`, {\n    method: "DELETE",\n  });\n};\n\nexport const fetchUserStats = async (\n  from: string,\n  to: string\n): Promise<Stat[]> => {\n  return fetchWrapper(`user/plays/stats?from=${from}&to=${to}`, {\n    method: "GET",\n  });\n};\n\nexport const fetchUserArtistHistory = async (\n  options?: APIOptions\n): Promise<APIPaginatedResult<{ uid: number; meta_value: string }>> => {\n  return fetchWrapper(\n    "user/plays/history/artists",\n    { method: "GET" },\n    options,\n    true\n  );\n};\n\nexport const fetchUserCollection = async (\n  options?: APIOptions\n): Promise<APIPaginatedResult<Track>> => {\n  return fetchWrapper("user/collection/", { method: "GET" }, options, true);\n};\n\nexport const fetchUserHistory = async (\n  options?: APIOptions\n): Promise<APIPaginatedResult<Track>> => {\n  return fetchWrapper("user/plays/history/", { method: "GET" }, options, true);\n};\n\nexport const fetchUserFavorites = async (\n  options?: APIOptions\n): Promise<APIPaginatedResult<Track>> => {\n  return fetchWrapper(\n    "user/favorites",\n    {\n      method: "GET",\n    },\n    options,\n    true\n  );\n};\n\nexport const addTrackToUserFavorites = async (id: number): Promise<Track[]> => {\n  return fetchWrapper("user/favorites", {\n    method: "POST",\n    body: JSON.stringify({\n      track_id: id,\n    }),\n  });\n};\n\nexport const checkTrackIdsForFavorite = async (\n  ids: number[]\n): Promise<{ track_id: number }[]> => {\n  return fetchWrapper("user/favorites/resolve", {\n    method: "POST",\n    body: JSON.stringify({\n      ids,\n    }),\n  });\n};\n\ninterface TagOptions extends APIOptions {\n  tag: string;\n}\n\nexport const fetchByTag = async ({\n  tag,\n  ...options\n}: TagOptions): Promise<APIPaginatedResult<TagResult>> => {\n  return fetchWrapper(\n    `tag/${tag}`,\n    {\n      method: "GET",\n    },\n    options,\n    true\n  );\n};\n/**\n *  Label endpoints\n */\n\nexport const fetchLabels = (\n  options?: APIOptions\n): Promise<APIPaginatedResult<Label>> => {\n  return fetchWrapper(`labels`, { method: "GET" }, options, true);\n};\n\nexport const fetchLabel = (labelId: number): Promise<Label> => {\n  return fetchWrapper(`labels/${labelId}`, {\n    method: "GET",\n  });\n};\n\nexport const fetchLabelReleases = (labelId: number): Promise<Release[]> => {\n  return fetchWrapper(`labels/${labelId}/releases`, {\n    method: "GET",\n  });\n};\n\nexport const fetchLabelArtists = (labelId: number): Promise<LabelArtist[]> => {\n  return fetchWrapper(`labels/${labelId}/artists`, {\n    method: "GET",\n  });\n};\n\nexport const fetchLabelAlbums = (labelId: number): Promise<LabelAlbum[]> => {\n  return fetchWrapper(`labels/${labelId}/albums`, {\n    method: "GET",\n  });\n};\n\n/**\n * Artist endpoints\n */\n\nexport const fetchArtists = (\n  options?: APIOptions\n): Promise<APIPaginatedResult<Artist>> => {\n  return fetchWrapper(\n    `artists`,\n    {\n      method: "GET",\n    },\n    options,\n    true\n  );\n};\n\nexport const fetchArtist = (artistId: number): Promise<Artist> => {\n  return fetchWrapper(`artists/${artistId}`, {\n    method: "GET",\n  });\n};\n\nexport const fetchArtistReleases = (artistId: number): Promise<Release[]> => {\n  return fetchWrapper(`artists/${artistId}/releases`, {\n    method: "GET",\n  });\n};\n\nexport const fetchArtistTopTracks = (artistId: number): Promise<Track[]> => {\n  return fetchWrapper(`artists/${artistId}/tracks/top`, {\n    method: "GET",\n  });\n};\n\n/**\n * Track endpoints\n */\n\nexport const fetchLatestTracks = (\n  options: APIOptions\n): Promise<APIPaginatedResult<Track>> => {\n  return fetchWrapper(\n    `tracks/${options.order !== "random" ? "latest" : ""}`,\n    {\n      method: "GET",\n    },\n    options,\n    true\n  ).then((results) => {\n    return { ...results, data: results.data.map((r: Track) => ({ ...r })) };\n  });\n};\n\nexport const fetchTrack = (trackId: number): Promise<Track> => {\n  return fetchWrapper(`tracks/${trackId}`, {\n    method: "GET",\n  });\n};\n\nexport const registerPlay = (\n  trackId: number\n): Promise<{ count: number; cost: number; total: string }> => {\n  return fetchWrapper(`user/plays`, {\n    method: "POST",\n    body: JSON.stringify({ track_id: trackId }),\n  });\n};\n\nexport const buyTrack = async (trackId: number) => {\n  return fetchWrapper(`user/plays/buy`, {\n    method: "POST",\n    body: JSON.stringify({\n      track_id: trackId,\n    }),\n  });\n};\n\nexport const checkPlayCountOfTrackIds = async (\n  ids: number[]\n): Promise<{ track_id: number; count: number }[]> => {\n  return fetchWrapper("user/plays/resolve", {\n    method: "POST",\n    body: JSON.stringify({\n      ids,\n    }),\n  });\n};\n\n/**\n *  Search endpoints\n */\n\nexport const fetchSearchResults = (\n  searchString: string\n): Promise<SearchResult[] | null> => {\n  return fetchWrapper(\n    "search/",\n    { method: "GET" },\n    // NOTE: API is looking for actual "+" (%2B) values instead of whitespace (%20)\n    { q: searchString.replace(/ /g, "+") }\n  );\n};\n\n')))}l.isMDXComponent=!0}}]);