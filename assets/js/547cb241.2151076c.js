"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[32],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>d});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var p=r.createContext({}),c=function(e){var n=r.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},l=function(e){var n=c(e.components);return r.createElement(p.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),m=c(t),d=o,f=m["".concat(p,".").concat(d)]||m[d]||u[d]||a;return t?r.createElement(f,s(s({ref:n},l),{},{components:t})):r.createElement(f,s({ref:n},l))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,s=new Array(a);s[0]=m;var i={};for(var p in n)hasOwnProperty.call(n,p)&&(i[p]=n[p]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var c=2;c<a;c++)s[c]=t[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3661:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var r=t(7462),o=(t(7294),t(3905));const a={sidebar_position:2,title:"Example API Calls"},s=void 0,i={unversionedId:"example-api-calls",id:"example-api-calls",title:"Example API Calls",description:"Explore sample client API calls, illustrated by the beam repository's Api.ts file...",source:"@site/docs/example-api-calls.md",sourceDirName:".",slug:"/example-api-calls",permalink:"/docs/example-api-calls",draft:!1,editUrl:"https://github.com/resonatecoop/beam/edit/main/src/services/Api.ts",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Example API Calls"},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/docs/overview"},next:{title:"Active Development",permalink:"/docs/category/active-development"}},p={},c=[],l={toc:c};function u(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,r.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Explore sample client API calls, illustrated by the ",(0,o.kt)("code",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/resonatecoop/beam"},"beam"))," repository's ",(0,o.kt)("code",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/resonatecoop/beam/blob/main/src/services/Api.ts"},"Api.ts"))," file..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { resonateUrl } from "../constants";\n\nexport const API = `${resonateUrl}api/`;\nexport const oidcStorage = `oidc.user:${process.env.REACT_APP_AUTHORITY}:${process.env.REACT_APP_CLIENT_ID}`;\n\nclass NotFoundError extends Error {\n  constructor(params: any) {\n    super(params);\n    Object.setPrototypeOf(this, NotFoundError.prototype);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, NotFoundError);\n    }\n\n    this.message = "Not Found";\n  }\n}\n\nexport const getToken = (apiVersion?: string | number) => {\n  let token: string | undefined = undefined;\n  try {\n    const stateString = localStorage.getItem("state");\n    const state = JSON.parse(stateString ?? "");\n    token = state?.token;\n  } catch (e) {}\n\n  let version = apiVersion ?? "v3";\n\n  try {\n    const oauthStateString = localStorage.getItem(oidcStorage);\n    const oauthState = JSON.parse(oauthStateString ?? "");\n    token = oauthState.access_token;\n    version = apiVersion ?? "v3";\n  } catch (e) {}\n  return { token: token, version };\n};\n\nexport const fetchWrapper = async (\n  url: string,\n  options: RequestInit,\n  apiOptions?: APIOptions,\n  pagination?: boolean,\n  contentType?: string\n) => {\n  const { token, version: apiVersion } = getToken(apiOptions?.apiVersion);\n  let fullUrl = `${API}${apiVersion}/${url}`;\n  if (apiOptions && options.method === "GET") {\n    const params = new URLSearchParams();\n    Object.keys(apiOptions).forEach((key) => {\n      params.set(key, `${apiOptions[key]}`);\n    });\n    fullUrl += `?${params}`;\n  }\n\n  return fetch(fullUrl, {\n    headers: {\n      "Content-Type": contentType ? contentType : "application/json",\n      ...(token ? { Authorization: `Bearer ${token}` } : {}),\n    },\n    ...options,\n  })\n    .then((result) => {\n      if (!result.ok) {\n        if (result.status === 404) {\n          throw new NotFoundError(result);\n        }\n      } else {\n        // go the desired response\n      }\n      return result.json();\n    })\n    .then((result) => {\n      if (pagination) {\n        return result;\n      }\n      return result.data;\n    });\n};\n\nexport interface FetchTrackGroupFilter extends APIOptions {\n  type?: TrackgroupType;\n}\n\nexport const fetchTrackGroups = async (\n  options?: FetchTrackGroupFilter\n): Promise<APIPaginatedResult<Trackgroup>> => {\n  return fetchWrapper(\n    "trackgroups",\n    {\n      method: "GET",\n    },\n    options,\n    true\n  );\n};\n\nexport const fetchTrackGroup = async (\n  id: string\n): Promise<TrackgroupDetail> => {\n  return fetchWrapper(`trackgroups/${id}`, {\n    method: "GET",\n  });\n};\n\ninterface TagOptions extends APIOptions {\n  tag: string;\n}\n\nexport const fetchByTag = async ({\n  tag,\n  ...options\n}: TagOptions): Promise<APIPaginatedResult<TagResult>> => {\n  return fetchWrapper(\n    `tag/${tag}`,\n    {\n      method: "GET",\n    },\n    options,\n    true\n  );\n};\n/**\n *  Label endpoints\n */\n\nexport const fetchLabels = (\n  options?: APIOptions\n): Promise<APIPaginatedResult<Label>> => {\n  return fetchWrapper(`labels`, { method: "GET" }, options, true);\n};\n\nexport const fetchLabel = (labelId: number): Promise<Label> => {\n  return fetchWrapper(`labels/${labelId}`, {\n    method: "GET",\n  });\n};\n\nexport const fetchLabelReleases = (labelId: number): Promise<Release[]> => {\n  return fetchWrapper(`labels/${labelId}/releases`, {\n    method: "GET",\n  });\n};\n\nexport const fetchLabelArtists = (labelId: number): Promise<LabelArtist[]> => {\n  return fetchWrapper(`labels/${labelId}/artists`, {\n    method: "GET",\n  });\n};\n\nexport const fetchLabelAlbums = (labelId: number): Promise<LabelAlbum[]> => {\n  return fetchWrapper(`labels/${labelId}/albums`, {\n    method: "GET",\n  });\n};\n\n/**\n * Artist endpoints\n */\n\nexport const fetchArtists = (\n  options?: APIOptions\n): Promise<APIPaginatedResult<Artist>> => {\n  return fetchWrapper(\n    `artists`,\n    {\n      method: "GET",\n    },\n    options,\n    true\n  );\n};\n\nexport const fetchArtist = (artistId: string): Promise<Artist> => {\n  return fetchWrapper(`artists/${artistId}`, {\n    method: "GET",\n  });\n};\n\nexport const fetchArtistReleases = (artistId: string): Promise<Release[]> => {\n  return fetchWrapper(`artists/${artistId}/releases`, {\n    method: "GET",\n  });\n};\n\nexport const fetchArtistTopTracks = (artistId: string): Promise<Track[]> => {\n  return fetchWrapper(`artists/${artistId}/tracks/top`, {\n    method: "GET",\n  });\n};\n\n/**\n * Track endpoints\n */\n\nexport const fetchLatestTracks = (\n  options: APIOptions\n): Promise<APIPaginatedResult<Track>> => {\n  return fetchWrapper(\n    `tracks/${options.order !== "random" ? "latest" : ""}`,\n    {\n      method: "GET",\n    },\n    options,\n    true\n  ).then((results) => {\n    return { ...results, data: results.data.map((r: Track) => ({ ...r })) };\n  });\n};\n\nexport const fetchTrack = (trackId: number): Promise<Track> => {\n  return fetchWrapper(`tracks/${trackId}`, {\n    method: "GET",\n  });\n};\n\n/**\n *  Search endpoints\n */\n\nexport const fetchSearchResults = (\n  searchString: string\n): Promise<SearchResult[] | null> => {\n  return fetchWrapper(\n    "search/",\n    { method: "GET" },\n    // NOTE: API is looking for actual "+" (%2B) values instead of whitespace (%20)\n    { q: searchString.replace(/ /g, "+") }\n  );\n};\n\n')))}u.isMDXComponent=!0}}]);